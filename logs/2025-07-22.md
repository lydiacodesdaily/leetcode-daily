# 🗓️ Daily Log — July 22, 2025 (Tuesday)
⏱️ **Hours Studied:** 8.5 hrs  

---

## 📘 LeetCode Problems Practiced

### ✅ Tree DFS / Binary Tree Traversals
- [x] 543. **Diameter of Binary Tree**  
  → Reviewed post-order DFS logic to calculate diameter (based on height of left + right)  
  → Clarified why we return `+1` for height but **not** for diameter

- [x] 863. **All Nodes Distance K in Binary Tree**  
  → Practiced parent-tracking via DFS, followed by multi-source BFS  
  → Dry-run included level-by-level traversal and visited set

- [x] 236. **Lowest Common Ancestor of a Binary Tree**  
  → Classic post-order DFS to find LCA of two guaranteed-present nodes

- [x] 1644. **LCA II**  
  → Same as 236 but added `(found_p, found_q)` flags to validate node existence  
  → Practiced dry run to ensure only returning LCA if both nodes are present

- [x] 1650. **LCA III (With Parent Pointers)**  
  → Practiced both the set-based and two-pointer solution  
  → Dry run to understand pointer alignment logic and why `a = a.parent if a else q` works

- [x] 1676. **LCA IV (Multiple Nodes)**  
  → Extended 236 using set-based lookup  
  → Built GitHub-style `.py` file with clean comments and dry-run trace

---

### ✅ Binary Search
- [x] 1539. **Kth Missing Positive Number**  
  → Reviewed brute force vs optimal binary search  
  → Dry-run of missing count formula: `missing = arr[i] - (i + 1)`  
  → Memory hook: "find first index where missing ≥ k → return `left + k`"

---

## 🛠️ System Design

- Watched videos and read articles on **Back-of-the-Envelope Calculations (BOTECs)**
- Still unclear on when and how to make certain assumptions
- Planning to revisit with guided frameworks for traffic estimation & latency budgeting

---

## 🔁 Review Notes

- ✅ Practiced dry-running in codepad for interview simulation
- ✅ Compared all 4 LCA variations side-by-side with key constraints
- ✅ Gained deeper clarity on how to extend base DFS logic to fit edge constraints (1644, 1676)
