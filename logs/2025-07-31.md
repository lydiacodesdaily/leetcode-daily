# 📅 Daily Log – July 31, 2025 (Thursday)

**Total Time:** 7.25 hours  
_“Kept momentum by combining system design videos with stepper workout — worked really well to prevent distractions.”_

---

## 🧠 Leetcode Practice – 5.25 hours (10 problems)

1. **[20. Valid Parentheses](https://leetcode.com/problems/valid-parentheses)**
   - ✅ Reviewed stack logic  
   - ⚠️ Forgot to check for remaining items in stack at end — key bug reminder.

2. **[133. Clone Graph](https://leetcode.com/problems/clone-graph)**
   - ✅ BFS with queue and hashmap  
   - Graph is already constructed; cloned nodes using `.val` and `.neighbors`.

3. **[921. Minimum Add to Make Parentheses Valid](https://leetcode.com/problems/minimum-add-to-make-parentheses-valid)**
   - Used `open` + `insertions` approach  
   - Preferred for clarity over stack-only variants.

4. **[498. Diagonal Traverse](https://leetcode.com/problems/diagonal-traverse)**
   - Indexed diagonals by `i + j`  
   - Practiced traversal in correct diagonal order.

5. **[1539. Kth Missing Positive Number](https://leetcode.com/problems/kth-missing-positive-number)**
   - Binary search on `i` where `arr[i] - (i + 1)` ≥ k  
   - Formula and return logic solidified.

6. **[863. All Nodes Distance K in Binary Tree](https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree)**
   - DFS to map `parent[node]`, then BFS for K-distance  
   - Understood when to use `return 0` in helper.

7. **[708. Insert into a Sorted Circular Linked List](https://leetcode.com/problems/insert-into-a-sorted-circular-linked-list)**
   - Practiced insertion with wraparound logic  
   - Covered tricky edge cases like uniform and single-node lists.

8. **[14. Longest Common Prefix](https://leetcode.com/problems/longest-common-prefix)**
   - Shrunk `prefix` using slicing  
   - Switched `.find()` to `.startswith()` for clearer intent.

9. **[19. Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list)**
   - ✅ Used dummy + two-pointer pattern  
   - Learned why `slow.next = slow.next.next` is preferred over `slow.next = fast`.

10. **[636. Exclusive Time of Functions](https://leetcode.com/problems/exclusive-time-of-functions)**
    - Timestamps are inclusive → added `+1` to execution time  
    - Moved `prev_time` to `timestamp + 1` to prep for next function.

---

## 🧱 System Design – 2 hours

_Watched while on stepper (habit stack worked very well)_

### HelloInterview Topics:
- 📺 **Design Facebook News Feed**
- 🧠 **Core Concepts:**
  - **Networking Essentials**
    - DNS → CDN → Load Balancer → App Server → DB
  - **API Design**
    - Focused on access patterns and shaping contracts
    - Not just endpoints — reinforced deeper API thinking

---

## ✏️ Reflections

- While I covered 10 Leetcode problems, I spent 5.25 hours — which feels **long for problems I’ve already solved before**.
- This helped me deeply re-process logic and correct subtle misunderstandings (e.g., `.find()` vs `.startswith()`, exclusive timestamps), but I now realize I can **go faster with structured recall**.
- I’ll experiment with a **timeboxed "Leetcode flashcard sprint"** next: aiming for <15 min/problem or <5 min if it’s pure recall.