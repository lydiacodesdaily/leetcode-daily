# ğŸ“… Daily Log â€“ August 1, 2025 (Friday)

**Total Time:** 5 hours  
(1.5 + 2.5 + 0.5 + 0.5)

---

## ğŸ§  Leetcode Practice â€“ 10 problems

### 1. [415. Add Strings](https://leetcode.com/problems/add-strings/)
- âœ… Solved correctly
- Reviewed digit-by-digit addition from the end with carry handling

---

### 2. [249. Group Shifted Strings](https://leetcode.com/problems/group-shifted-strings/)
- âœ… Got the grouping by shift key logic correct
- âŒ Didnâ€™t compute the full shift key `(ord(c) - ord(s[0])) % 26` correctly
- ğŸ” Learned that the shift key **normalizes each string** based on the relative distance from the first char
- ğŸ§  Memory Hook: `shift = [(ord(c) - ord(s[0])) % 26 for c in s]` ensures that `"abc"`, `"bcd"`, and `"xyz"` map to the same pattern `[0,1,2]`

---

### 3. [207. Course Schedule](https://leetcode.com/problems/course-schedule/)
- âœ… Did relatively well
- âŒ Made a few small mistakes
- ğŸ’¡ Reviewed topological sort using BFS
- ğŸ” Clarified that `for nei in req_map(course):` was incorrect syntax â€” should be `req_map[course]`
- ğŸ§  Memory Hook: use `in_degree[]`, `req_map[]`, and queue with visited count to detect cycles

---

### 4. [2. Add Two Numbers](https://leetcode.com/problems/add-two-numbers/)
- âœ… Solid understanding of reverse-order addition using linked lists
- ğŸ§  Clarified follow-up: if input is in **forward order**, use **two stacks**
- ğŸ” Stack approach is interview-friendlier than reversing input because it avoids modifying input nodes
- ğŸ§  Memory Hook: push all digits â†’ pop from both stacks â†’ build output from back (prepend)

---

### 5. [270. Closest Binary Search Tree Value](https://leetcode.com/problems/closest-binary-search-tree-value/)
- âœ… Solved using iterative BST traversal
- ğŸ§  Memory Hook: compare `abs(node.val - target)` with current `closest`
- Used BST property to prune: if target < node.val â†’ go left; else â†’ go right

---

### 6. [219. Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/)
- âœ… Used a sliding window with a set
- ğŸ§  Memory Hook: maintain a set of last `k` values â†’ remove oldest as window slides
- Learned that although `last_seen` dict is simpler, using a **set as a window** fits better with your mental model

---

### 7. [26. Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)
- âœ… Understood the two-pointer approach
- â“ Slightly fuzzy on `write = 0`, `read = 1`, and final return `write + 1`
- ğŸ” Clarified that `write` is an index â†’ return count = `write + 1`
- ğŸ§  Memory Hook: if `nums[read] != nums[write]`, increment `write`, then copy `nums[read] â†’ nums[write]`

---

### 8. [647. Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/)
- âœ… Used expand-around-center method
- ğŸ” Expanded from both odd and even centers
- ğŸ§  Memory Hook: center = `(i,i)` and `(i,i+1)` â†’ expand while chars match

---

### 9. [523. Continuous Subarray Sum](https://leetcode.com/problems/continuous-subarray-sum/)
- âŒ Initially thought sliding window would work
- âœ… Correct solution is prefix sum + hashmap
- ğŸ§  Memory Hook: if `(prefix_sum % k)` has been seen before at index `j`, and `i - j >= 2`, the subarray is divisible by `k`
- ğŸ” Also handled the edge case when `k == 0`

---

### 10. [173. Binary Search Tree Iterator](https://leetcode.com/problems/binary-search-tree-iterator/)
- âŒ Initially unclear about what â€œin-order traversalâ€ really meant (left â†’ node â†’ right)
- âœ… Understood fully after walking through a dry run
- âœ… Now understand stack is used to simulate recursive in-order traversal lazily
- ğŸ” Reviewed why we push all left children on init and after visiting a right child
- ğŸ§  Memory Hook:
  - stack simulates in-order
  - `.next()` = pop â†’ push rightâ€™s left path
  - `.hasNext()` = stack not empty