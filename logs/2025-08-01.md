# 📅 Daily Log – August 1, 2025 (Friday)

**Total Time:** 5 hours  
(1.5 + 2.5 + 0.5 + 0.5)

---

## 🧠 Leetcode Practice – 10 problems

### 1. [415. Add Strings](https://leetcode.com/problems/add-strings/)
- ✅ Solved correctly
- Reviewed digit-by-digit addition from the end with carry handling

---

### 2. [249. Group Shifted Strings](https://leetcode.com/problems/group-shifted-strings/)
- ✅ Got the grouping by shift key logic correct
- ❌ Didn’t compute the full shift key `(ord(c) - ord(s[0])) % 26` correctly
- 🔍 Learned that the shift key **normalizes each string** based on the relative distance from the first char
- 🧠 Memory Hook: `shift = [(ord(c) - ord(s[0])) % 26 for c in s]` ensures that `"abc"`, `"bcd"`, and `"xyz"` map to the same pattern `[0,1,2]`

---

### 3. [207. Course Schedule](https://leetcode.com/problems/course-schedule/)
- ✅ Did relatively well
- ❌ Made a few small mistakes
- 💡 Reviewed topological sort using BFS
- 🔍 Clarified that `for nei in req_map(course):` was incorrect syntax — should be `req_map[course]`
- 🧠 Memory Hook: use `in_degree[]`, `req_map[]`, and queue with visited count to detect cycles

---

### 4. [2. Add Two Numbers](https://leetcode.com/problems/add-two-numbers/)
- ✅ Solid understanding of reverse-order addition using linked lists
- 🧠 Clarified follow-up: if input is in **forward order**, use **two stacks**
- 🔍 Stack approach is interview-friendlier than reversing input because it avoids modifying input nodes
- 🧠 Memory Hook: push all digits → pop from both stacks → build output from back (prepend)

---

### 5. [270. Closest Binary Search Tree Value](https://leetcode.com/problems/closest-binary-search-tree-value/)
- ✅ Solved using iterative BST traversal
- 🧠 Memory Hook: compare `abs(node.val - target)` with current `closest`
- Used BST property to prune: if target < node.val → go left; else → go right

---

### 6. [219. Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/)
- ✅ Used a sliding window with a set
- 🧠 Memory Hook: maintain a set of last `k` values → remove oldest as window slides
- Learned that although `last_seen` dict is simpler, using a **set as a window** fits better with your mental model

---

### 7. [26. Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)
- ✅ Understood the two-pointer approach
- ❓ Slightly fuzzy on `write = 0`, `read = 1`, and final return `write + 1`
- 🔍 Clarified that `write` is an index → return count = `write + 1`
- 🧠 Memory Hook: if `nums[read] != nums[write]`, increment `write`, then copy `nums[read] → nums[write]`

---

### 8. [647. Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/)
- ✅ Used expand-around-center method
- 🔁 Expanded from both odd and even centers
- 🧠 Memory Hook: center = `(i,i)` and `(i,i+1)` → expand while chars match

---

### 9. [523. Continuous Subarray Sum](https://leetcode.com/problems/continuous-subarray-sum/)
- ❌ Initially thought sliding window would work
- ✅ Correct solution is prefix sum + hashmap
- 🧠 Memory Hook: if `(prefix_sum % k)` has been seen before at index `j`, and `i - j >= 2`, the subarray is divisible by `k`
- 🔍 Also handled the edge case when `k == 0`

---

### 10. [173. Binary Search Tree Iterator](https://leetcode.com/problems/binary-search-tree-iterator/)
- ❌ Initially unclear about what “in-order traversal” really meant (left → node → right)
- ✅ Understood fully after walking through a dry run
- ✅ Now understand stack is used to simulate recursive in-order traversal lazily
- 🔍 Reviewed why we push all left children on init and after visiting a right child
- 🧠 Memory Hook:
  - stack simulates in-order
  - `.next()` = pop → push right’s left path
  - `.hasNext()` = stack not empty