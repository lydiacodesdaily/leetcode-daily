# 🗓️ Daily Log —  August 20, 2025 (Wednesday)

**Total Study Time:** 8 hours  
(2 + 1.5 + 1 + 2.25 + 1.25)

---

## 🏗 System Design — 4.5 hrs
- Worked on **system design templates**:
  - Organized **back-of-the-envelope estimations**:
    - Fixed payload sizes for throughput/latency estimates
    - What questions to ask first
    - How different estimation values should influence design choices
  - Identified **key components and tradeoffs** for common architectures
  - Thought through **bottlenecks and scaling strategies**
- Notes: still refining the template so it feels natural under interview pressure.

---

## 🔢 LeetCode — 3.5 hrs

### 🔄 Review from Yesterday
- Q1: 1757. Recyclable and Low Fat Products [DNR]  
- Q2: 595. Big Countries [DNR]  
- Q3: 1148. Article Views I  
- Q4: 176. Second Highest Salary  
  - ✅ OFFSET trick (`LIMIT 1 OFFSET 1`) vs subquery with `MAX()`.
- Q5: 570. Managers with at Least 5 Direct Reports  
- Q6: 1070. Product Sales Analysis III 

### 🆕 New Problems
- Q1: 303. Range Sum Query - Immutable  
  - Prefix sum array with **n+1 length trick** → clean O(1) queries.  
- Q2: 1353. Maximum Number of Events That Can Be Attended  
  - ✅ Recognized **heap**, not stack.  
  - `heap` = available events by endDay.  
  - `i` = index into sorted events.  
  - `day` = simulation clock.  
  - `total` = number of events attended.  
  - Heap ops = O(log k) each → O(n log n) total.  
- Q3: 933. Number of Recent Calls  
  - Sliding window with `deque` → amortized O(1).  
  - Not binary search since queries always at latest time.  
- Q4: 784. Letter Case Permutation  
  - Backtracking / DFS → O(n * 2^k).  
  - Each letter = 2 branches (lower/upper), digits = 1 branch.  
- Q5: 29. Divide Two Integers

---

## ✅ Reflections
- Felt like I didn’t cover as much as I wanted in 8 hrs → need to push for tighter focus.  
- Began tagging certain LeetCode problems as **[DNR] (Do Not Review)** to save future time.  
- Key insights today:  
  - SQL subqueries: why/when correlated subqueries are required.  
  - Sliding window vs binary search recognition (933).  
  - Heap vs stack distinction (1353).  
  - Backtracking complexity patterns (784).  
- Next step: keep reinforcing **time complexity intuition** and consolidate **system design template** into something lightweight but structured.  