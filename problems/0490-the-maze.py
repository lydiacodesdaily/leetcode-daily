# LeetCode 490 - The Maze
# https://leetcode.com/problems/the-maze/
#
# ✅ Problem
# A ball rolls in a grid maze. From a cell, when it moves in one of 4 directions,
# it keeps rolling until it hits a wall (1). It then stops at the last empty cell (0)
# before the wall. Given start and destination cells, return True if the ball can
# stop exactly at destination; otherwise False.
#
# 📚 Pattern
# Graph search on implicit graph of "stop cells" (BFS or DFS).
#
# 🔍 Key Insight
# - Nodes are not every adjacent cell; nodes are the cells where the ball STOPS.
# - From a stop cell, "edges" are generated by rolling in 4 dirs until the next stop.
# - Use BFS/DFS over these stop cells with a visited set to avoid cycles.
#
# 🧠 Memory Hook
# "Roll till wall → back one → that's your neighbor"
# Only enqueue/visit the stop positions, not every intermediate cell.
#
# ✅ Time Complexity
# O(m*n*4) ~ O(mn). Each cell can become a stop at most once; each expansion rolls at most
# m or n steps per direction amortized to O(1) per cell due to visited pruning.
# ✅ Space Complexity
# O(mn) for visited/queue.

from typing import List
from collections import deque

class Solution:
    def hasPath(self, maze: List[List[int]], start: List[int], destination: List[int]) -> bool:
        m, n = len(maze), len(maze[0])
        sr, sc = start
        tr, tc = destination

        # Early exit
        if [sr, sc] == [tr, tc]:
            return True

        dirs = [(1,0), (-1,0), (0,1), (0,-1)]
        q = deque([(sr, sc)])
        visited = set([(sr, sc)])

        while q:
            r, c = q.popleft()

            for dr, dc in dirs:
                nr, nc = r, c
                # 🔄 Roll until the wall (or boundary)
                while 0 <= nr + dr < m and 0 <= nc + dc < n and maze[nr + dr][nc + dc] == 0:
                    nr += dr
                    nc += dc

                # nr,nc is a stop cell
                if (nr, nc) in visited:
                    continue
                if [nr, nc] == [tr, tc]:
                    return True

                visited.add((nr, nc))
                q.append((nr, nc))

        return False

# 🔄 Dry Run (conceptual):
# maze =
# 0 0 1 0 0
# 0 0 0 0 0
# 0 0 0 1 0
# 1 1 0 1 1
# 0 0 0 0 0
# start = [0,4], dest = [4,4]
# From (0,4) roll left -> (0,3)->(0,1); right -> blocked; up -> blocked; down -> (4,4)
# We hit destination after rolling down → True.